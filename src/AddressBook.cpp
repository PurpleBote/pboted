/**
 * Copyright (c) 2019-2021 polistern
 */

#include <utility>

#include "AddressBook.h"
#include "FileSystem.h"
#include "Logging.h"

namespace pbote {

AddressBook::AddressBook() {}

AddressBook::AddressBook(std::string path, std::string pass)
    : filePath_(std::move(path)), passwordHolder_(std::move(pass)) {}

AddressBook::~AddressBook() {}

void AddressBook::load() {
  LogPrint(eLogInfo, "AddressBook: load: Load contacts from FS");
  std::string delimiter = ";";
  std::vector<std::string> address_list = read();

  if (!address_list.empty()) {
    for (auto address_str: address_list) {
      size_t pos;
      Contact contact;

      contact.alias = address_str.substr(0, address_str.find(delimiter));
      address_str.erase(0, address_str.find(delimiter) + delimiter.length());
      contact.name = address_str.substr(0, address_str.find(delimiter));
      address_str.erase(0, address_str.find(delimiter) + delimiter.length());
      contact.dest = address_str.substr(0, address_str.size());

      if (!contact.alias.empty()) {
        LogPrint(eLogDebug, "AddressBook: load: alias: ", contact.alias,
                 ", name: ", contact.name, ", dest: ", contact.dest);
        contacts.push_back(contact);
      }
    }
  }

  if (!contacts.empty()) {
    LogPrint(eLogInfo, "AddressBook: contact(s) loaded: ", contacts.size());
  }
}

void AddressBook::save() {
  LogPrint(eLogInfo, "AddressBook: save contacts to FS");
  std::string addressbook_file_path = pbote::fs::DataDirPath("addressbook.txt");
  std::ofstream addressbook_file(addressbook_file_path);

  if (!addressbook_file.is_open()) {
    LogPrint(eLogError, "AddressBook: can't open file ", addressbook_file_path);
    return;
  }

  addressbook_file << "# Each line is in the format: <alias>;<name>;<dest>;\n";
  addressbook_file << "#   alias = for replacement in SMTP (<user>@<domain>)\n";
  addressbook_file << "#   name = pupblic name of identity\n";
  addressbook_file << "#   dest = base64 public bote address\n";
  addressbook_file << "# The fields are separated by a semicolon character.\n";
  addressbook_file << "# Lines starting with a # are ignored.\n";
  addressbook_file << "# Do not edit this file while pboted is running as it will be overwritten.\n\n";

  for (const auto &contact: contacts) {
    addressbook_file << contact.alias << ";" << contact.name << ";" << contact.dest << "\n";
  }

  addressbook_file.close();
  LogPrint(eLogDebug, "AddressBook: contacts saved to FS");
}

void AddressBook::add(std::string &alias, std::string &name, std::string &address) {
  Contact new_contact{};
  new_contact.alias = alias;
  new_contact.name = name;
  new_contact.dest = address;
  contacts.push_back(new_contact);
}

bool AddressBook::name_exist(const std::string &name) {
  for (const auto& contact : contacts)
    if (contact.name == name)
      return true;
  return false;
}

bool AddressBook::alias_exist(const std::string &alias) {
  for (const auto& contact : contacts)
    if (contact.alias == alias)
      return true;
    return false;
}

std::string AddressBook::address_for_name(const std::string &name) {
  if (name_exist(name)) {
    for (const auto& contact : contacts)
      if (contact.name == name)
        return contact.dest;
  }
  return {};
}

std::string AddressBook::address_for_alias(const std::string &alias) {
  if (alias_exist(alias)) {
    for (const auto& contact : contacts)
      if (contact.alias == alias)
        return contact.dest;
  }
  return {};
}

void AddressBook::remove(const std::string &name) {
  if (name_exist(name)) {
    for (auto i = contacts.begin(); i != contacts.end(); i++) {
      if (i->name == name)
        contacts.erase(i);
    }
  }
}

//void AddressBook::setPassword() {}

//void AddressBook::changePassword() {}

//void AddressBook::encrypt() {}

//void AddressBook::decrypt() {}

std::vector<std::string> AddressBook::read() {
  std::string addressbook_file_path = pbote::fs::DataDirPath("addressbook.txt");
  LogPrint(eLogInfo, "AddressBook: load from ", addressbook_file_path);
  std::ifstream addressbook_file(addressbook_file_path);

  if (!addressbook_file.is_open()) {
    LogPrint(eLogError, "AddressBook: can't open file ", addressbook_file_path);
    return {};
  }

  std::vector<std::string> address_list;

  for (std::string line; getline(addressbook_file, line);) {
    if (!line.empty() && line[0] != ('\n') && line[0] != '#') {
      address_list.push_back(line);
    }
  }
  return address_list;
}

} // namespace pbote
