/**
 * Copyright (C) 2019-2022, polistern
 * Copyright (C) 2022, The PurpleBote Team
 *
 * This file is part of pboted and licensed under BSD3
 *
 * See full license text in LICENSE file at top of project tree
 */

#include <utility>

#include "AddressBook.h"
#include "FileSystem.h"
#include "Logging.h"

namespace pbote
{

AddressBook::AddressBook () {}

AddressBook::AddressBook (std::string path, std::string pass)
  : m_addressbook_path (std::move (path)),
    m_password_holder (std::move (pass))
{
}

AddressBook::~AddressBook ()
{
  //save ();
}

void
AddressBook::load ()
{
  LogPrint (eLogInfo, "AddressBook: load: Load contacts from FS");
  std::string delimiter = ";";
  std::vector<std::string> address_list = read ();

  if (!address_list.empty ())
    {
      for (auto address_str : address_list)
        {
          // size_t pos;
          Contact contact;

          contact.alias = address_str.substr (0, address_str.find (delimiter));
          address_str.erase (0, address_str.find (delimiter)
                                    + delimiter.length ());
          contact.name = address_str.substr (0, address_str.find (delimiter));
          address_str.erase (0, address_str.find (delimiter)
                                    + delimiter.length ());
          contact.dest = address_str.substr (0, address_str.size ());

          if (!contact.alias.empty ())
            {
              LogPrint (eLogDebug, "AddressBook: load: alias: ", contact.alias,
                        ", name: ", contact.name, ", dest: ", contact.dest);
              m_contacts.push_back (contact);
            }
        }
    }

  if (!m_contacts.empty ())
    {
      LogPrint (eLogInfo,
                "AddressBook: load: Contact(s) loaded: ", m_contacts.size ());
    }
}

void
AddressBook::save ()
{
  LogPrint (eLogInfo, "AddressBook: save: Save contacts to FS");
  std::string addressbook_file_path
      = pbote::fs::DataDirPath (ADDRESS_BOOK_FILE_NAME);
  std::ofstream addressbook_file (addressbook_file_path);

  if (!addressbook_file.is_open ())
    {
      LogPrint (eLogWarning, "AddressBook: save: Can't open file ",
                addressbook_file_path);
      return;
    }

  addressbook_file << "# Each line is in the format: <alias>;<name>;<dest>;\n";
  addressbook_file
      << "#   alias = for replacement in SMTP (<user>@<domain>)\n";
  addressbook_file << "#   name = pupblic name of identity\n";
  addressbook_file << "#   dest = base64 public bote address\n";
  addressbook_file << "# The fields are separated by a semicolon character.\n";
  addressbook_file << "# Lines starting with a # are ignored.\n";
  addressbook_file << "# Do not edit this file while pboted is running as it "
                      "will be overwritten.\n\n";

  for (const auto &contact : m_contacts)
    {
      addressbook_file << contact.alias << ";" << contact.name << ";"
                       << contact.dest << "\n";
    }

  addressbook_file.close ();
  LogPrint (eLogDebug, "AddressBook: save: Contacts saved to ",
            ADDRESS_BOOK_FILE_NAME);
}

void
AddressBook::add (const std::string &alias,
                  const std::string &name,
                  const std::string &address)
{
  Contact new_contact{};

  new_contact.alias = alias;
  new_contact.name = name;
  new_contact.dest = address;

  m_contacts.push_back (new_contact);
}

bool
AddressBook::name_exist (const std::string &name)
{
  LogPrint (eLogDebug, "AddressBook: name_exist: name : ", name);

  for (const auto &contact : m_contacts)
    {
      LogPrint (eLogDebug,
        "AddressBook: name_exist: contact.name : ", contact.name);

      if (contact.name.compare (name) == 0)
        return true;
    }

  return false;
}

bool
AddressBook::alias_exist (const std::string &alias)
{
  LogPrint (eLogDebug, "AddressBook: alias_exist: alias : ", alias);

  for (const auto &contact : m_contacts)
    {
      LogPrint (eLogDebug,
        "AddressBook: alias_exist: contact.alias : ", contact.alias);

      if (contact.alias.compare (alias) == 0)
        return true;
    }

  return false;
}

std::string
AddressBook::address_for_name (const std::string &name)
{
  if (name_exist (name))
    return {};

  for (const auto &contact : m_contacts)
    if (contact.name.compare (name) == 0)
      return contact.dest;

  return {};
}

std::string
AddressBook::address_for_alias (const std::string &alias)
{
  if (!alias_exist (alias))
    return {};
    
  for (const auto &contact : m_contacts)
    if (contact.alias.compare (alias) == 0)
      return contact.dest;
    
  return {};
}

void
AddressBook::remove (const std::string &name)
{
  if (!name_exist (name))
    return;
  
  auto itr = m_contacts.begin ();
  while (itr != m_contacts.end ())
    {
      if (itr->name.compare(name) == 0)
      {
        m_contacts.erase (itr);
        break;
      }
      ++itr;
    }
}

/* ToDo
void
AddressBook::set_password ()
{
}
*/

/* ToDo
void
AddressBook::change_password ()
{
}
*/

/* ToDo
void
AddressBook::encrypt ()
{
}
*/

/* ToDo
void
AddressBook::decrypt ()
{
}
*/

std::vector<std::string>
AddressBook::read ()
{
  if (m_addressbook_path.empty ())
    m_addressbook_path = pbote::fs::DataDirPath (ADDRESS_BOOK_FILE_NAME);

  LogPrint (eLogInfo, "AddressBook: read: Try to load from ",
            m_addressbook_path);
  std::ifstream addressbook_file (m_addressbook_path);

  if (!addressbook_file.is_open ())
    {
      LogPrint (eLogWarning, "AddressBook: read: Can't open file ",
                m_addressbook_path);
      return {};
    }

  std::vector<std::string> address_list;

  for (std::string line; getline (addressbook_file, line);)
    {
      if (!line.empty () && line[0] != ('\n') && line[0] != '#')
        {
          address_list.push_back (line);
        }
    }
  return address_list;
}

} // namespace pbote
